# 关系

## 9.1

symmetric 对称

antisymmetric  反对称

asymmetric  非对称（对角线元素也不可出现）

irreflexive 反自反性

reflexive 自反性

## 9.2

primary key 主键

composite key 复合键

selection operator 选择运算符 —— $S_{c}$，作用在任意n元域上的A集合，R是A上满足c的关系，有运算符的运算规则为：

$\forall R\subseteq A , S_{C}(R) = \{a \in R | S_{C}(a) = T\} $

简单点说就是，C是一个

## 9.3

矩阵运算中关系的复合满足：$$\mathbf{M}_{R_2 \circ R_1} = \mathbf{M}_{R_1} \odot \mathbf{M}_{R_2}$$

布尔乘法 $C = A \odot B$ 的定义为：$$c_{ij} = \bigvee_{k=1}^n (a_{ik} \land b_{kj})$$

directed gragh 有向图

## 9.4

transitive closures 传递关系的闭包

## 9.6

partial orderings 偏序关系

poset 偏序集

covering relation 覆盖关系，可以理解为最近的关系，即在偏序关系中（a，b）是覆盖关系说明它满足偏序，且a与b不等，且不存在a与中间还有别的元素，在哈斯图上表示就是为一条线段的前后元素表示一对覆盖关系

# 9.1

commutative operation 可交换运算符

associative operation 可结合运算符

# 9.2

intersection 交集

subsemigroup 子半群

**半群 (Semigroup) $(S, *)$：** 一个非空集合 $S$ 连同其上的一个二元运算 $*$，满足：

1. **封闭性 (Closure)：** 对于所有 $x, y \in S$，有 $x * y \in S$。
2. **结合律 (Associativity)：** 对于所有 $x, y, z \in S$，有 $x * (y * z) = (x * y) * z$。

**子半群 (Subsemigroup) $(A, *)$：** 设 $(S, *)$ 是一个半群，如果 $A$ 是 $S$ 的非空子集（$A \subseteq S, A \ne \emptyset$），并且 $A$ 上的限制运算 $*$ 满足：

1. **封闭性：** 对于所有 $x, y \in A$，有 $x * y \in A$。

 isomorphisms 同构

**半群同构 (Semigroup Isomorphism)：** 设 $(A, *)$ 和 $(B, \circ)$ 是两个半群。映射 $h: A \to B$ 如果满足以下两个条件，则称 $h$ 是一个同构：

1. **运算保持性 (Homomorphism Property)：** 对于所有 $x, y \in A$，有 $h(x * y) = h(x) \circ h(y)$。
2. **双射性 (Bijectivity)：** $h$ 是一个双射（即既是单射又是满射）。

# 9.3

定义笛卡尔积上的运算：

- 半群 $(S \times T, \circ)$： $S \times T = \{(s, t) \mid s \in S, t \in T\}$。其运算 $\circ$ 定义为分量运算：

	$$(s_1, t_1) \circ (s_2, t_2) = (s_1 * s_2, t_1 *' t_2)$$

- 半群 $(T \times S, \bullet)$： $T \times S = \{(t, s) \mid t \in T, s \in S\}$。其运算 $\bullet$ 也定义为分量运算：

	$$(t_1, s_1) \bullet (t_2, s_2) = (t_1 *' t_2, s_1 * s_2)$$

	要证明两个代数结构同构，我们需要构造一个双射 $\phi$ 并在运算上是保持的。

	我们构造映射 $\phi: S \times T \to T \times S$ 如下：

	$$\phi((s, t)) = (t, s)$$对于任意 $(s, t) \in S \times T$。



同余关系 (Congruence Relation)： 在代数结构 $(S, *)$ 上的一个等价关系 $R$ 是一个同余关系，如果它满足兼容性（或代数性）：

$$\text{若 } a R b \text{ 且 } c R d \text{，则 } (a * c) R (b * d)$$



quotient semigroup 商半群



**自然同态**（或**典范满同态**）是一个特殊的映射，它将半群 $S$ 的每个元素映射到它所属的等价类。

映射 $f_R: S \to S/R$ 的定义为：

$$f_R(x) = [x]$$



## 同态性质（Homomorphism Property）详解

### 1. 什么是同态？

**同态 (Homomorphism)** 是一种特殊的映射，它**保持**了两个代数结构之间的运算规则。

设 $(A, *)$ 和 $(B, \circ)$ 是两个具有相同类型运算（例如都是半群）的代数结构。

映射 $f: A \to B$ 是一个同态，当且仅当它满足同态性质。

### 2. 同态性质的定义

对于 $A$ 中任意两个元素 $x$ 和 $y$，同态性质要求：

$$f(x * y) = f(x) \circ f(y)$$



## 自由半群 (Free Semigroup) 详解

### 1. 概念定义

一个由非空集合 $A$ 生成的**自由半群**，通常记作 $A^+$。

**生成集合 $A$**（也称为字母表或字符集）可以包含任意元素，比如 $A = \{a, b\}$ 或 $A = \{0, 1\}$。

**集合 $A^+$** 是由 $A$ 中元素通过**有限次连接**（Concatenation，或称连接）运算得到的所有**非空**序列（即字符串或单词）的集合。

**运算 $\cdot$** 就是**连接运算**：将两个序列首尾相接。

例子：

如果 $A = \{0, 1\}$，那么 $A^+$ 中的元素包括：

- 长度 1：$0, 1$

- 长度 2：00, 01, 10, 11$

- 度 3：$000, 001, ..., 111$

- 等等...

	如果 $\alpha = 01$，$\beta = 110$，那么 $\alpha \cdot \beta = 01110$。

### 2. 为什么叫“自由”？

“自由”意味着这种结构**只受限于半群的基本公理（封闭性和结合律）**，而**没有**施加任何额外的限制或关系。

- **没有交换律：** 在 $A^+$ 中，通常 $\alpha \cdot \beta \ne \beta \cdot \alpha$ (例如 $01 \ne 10$)。
- **没有幂等元：** 对于任意 $\alpha \in A^+$， $\alpha \cdot \alpha \ne \alpha$ (除非 $A$ 是空集，但 $A^+$ 要求非空)。
- **没有幺元和逆元：** $A^+$ 不包含空字符串 $\lambda$，因此没有幺元。



同构：双射+保持运算结构

![eef5a49e-f2aa-4504-b9e4-b9cf921f25ea](../../markdownnote/eef5a49e-f2aa-4504-b9e4-b9cf921f25ea.png)



# 9.4

**复合运算** (operation of composition)



# 9.5

## 正规子群（Normal Subgroup）的通俗解释

### 核心概念：左右陪集要相等

要理解正规子群，首先要从**陪集（Coset）**讲起。

在一个群 $G$ 中，如果 $H$ 是它的一个子群，我们可以用 $G$ 中的元素 $a$ 来“偏移” $H$：

- **左陪集 (Left Coset):** $a H = \{a h \mid h \in H\}$
- **右陪集 (Right Coset):** $H a = \{h a \mid h \in H\}$

**正规子群的代数定义：** $N$ 是 $G$ 的一个正规子群（记作 $N \lhd G$），当且仅当对于 $G$ 中所有元素 $a$，其左陪集等于右陪集。

$$\mathbf{a N = N a \quad \text{对于所有 } a \in G}$$

$N \lhd G \iff a^{-1} N a = N$，这正是 $a N = N a$ 的另一种代数表达形式。





# 群

![Snipaste_2025-11-02_15-48-13](Snipaste_2025-11-02_15-48-13.png)

![Snipaste_2025-11-02_15-51-11](Snipaste_2025-11-02_15-51-11.png)

![Snipaste_2025-11-02_15-52-18](Snipaste_2025-11-02_15-52-18.png)

![Snipaste_2025-11-02_16-11-10](Snipaste_2025-11-02_16-11-10.png)

![Snipaste_2025-11-02_16-12-29](Snipaste_2025-11-02_16-12-29.png)

说明循环群就两种

![Snipaste_2025-11-02_16-34-32](Snipaste_2025-11-02_16-34-32.png)

![Snipaste_2025-11-02_16-36-28](Snipaste_2025-11-02_16-36-28.png)









## 📚 11.1 二元信息码与检错码

本节主要介绍编码的基本概念、为什么需要编码，以及如何通过码的“距离”来检测错误。

### 1. 编码的基本概念

- **报文 (Message):** 信息的最小单位，是一个有限字母表中字符的有限序列。
- **字 (Word):** 在二元编码中，我们使用字母表 $B = \{0, 1\}$。一个“字”是m个0和1的序列（即 $B^m$ 中的一个元素）。
- $B^m$ **群:** 集合 $B^m$ 在二元运算 $\oplus$（模2加法）下是一个群。
	- **单位元:** $\overline{0} = (0, 0, \dots, 0)$。
	- **逆元:** 每个元素是它自身的逆（因为 $x \oplus x = \overline{0}$）。
- **传输过程:**
	1. **编码 (Encoding):** 为了减少噪声干扰，我们选取一个整数 $n > m$，并使用一个**单射**（一对一）函数 $e: B^m \rightarrow B^n$。
	2. $e$ 称为 **(m, n) 编码函数**。
	3. 对于 $b \in B^m$，$x = e(b) \in B^n$ 称为**代码字 (Codeword)**。
	4. **传输:** 代码字 $x$ 通过传输通道发送。
	5. **接收:** 收到 $x_t \in B^n$。如果通道有噪声，$x_t$ 可能不等于 $x$。
- **k个错误:** 如果 $x$ 和 $x_t$ 在 $k$ 个或更少的位置上不同，则称传输有 $k$ 个或更少的错误。

### 2. 检错 (Error Detection)

- **检错定义:** 如果一个代码字 $x=e(b)$ 发生了 $k$ 个或更少的错误，导致收到的字 $x_t$ **不是一个代码字**，那么我们就说这个编码 $e$ **能检测k个或更少的错误**。
- **权 (Weight):** $x \in B^n$ 的权 $|x|$ 是 $x$ 中1的个数。
- **例1：奇偶校验码 (Parity Check Code)**
	- 这是一个 $(m, m+1)$ 编码。
	- $e(b_1 \dots b_m) = b_1 \dots b_m b_{m+1}$。
	- $b_{m+1}$ 的取值使得 $e(b)$ 的总权重为**偶数**。
	- **检错能力:** 这种编码可以检测出**奇数个**错误。如果发生1个错误，收到的 $x_t$ 权重变为奇数，我们就能发现它不是一个合法的代码字。
	- **缺点:** 无法检测偶数个错误。

### 3. Hamming 距离 (Hamming Distance)

- **定义:** $B^m$ 中两个字 $x$ 和 $y$ 之间的 Hamming 距离 $\delta(x, y)$ 是指 $x$ 和 $y$ **不相同的位置数**。
- **计算:** $\delta(x, y) = |x \oplus y|$ (即 $x \oplus y$ 的权)。
- **距离性质 (定理1):**
	- $\delta(x, y) \ge 0$
	- $\delta(x, y) = 0 \iff x = y$
	- $\delta(x, y) = \delta(y, x)$
	- $\delta(x, y) \le \delta(x, z) + \delta(z, y)$ (三角不等式)
- **最短距离 (Minimum Distance):** 编码函数 $e$ 的最短距离是所有**不同**代码字之间距离的最小值。

#### 核心考点：检错能力与最短距离

- **定理2:** 一个编码 $e$ 能检测 $k$ 个或更少的错误 **当且仅当** 它的最短距离至少是 $k+1$。
- **解题方法 (如何求** $e$ **能检测多少个错误):**
	1. 找出 $e$ 的最短距离 $d_{min}$。
	2. 解不等式 $d_{min} \ge k+1$。
	3. 得到 $k \le d_{min} - 1$。
	4. $e$ 能检测的最多错误数就是 $d_{min} - 1$。
- **示例 (例6):** 某 (3,8) 编码的最短距离是 3。根据定理2， $3 \ge k+1$，解得 $k \le 2$。因此，该代码能检测2个或更少的错误。

### 4. 群码 (Group Codes)

- **定义:** 一个 $(m, n)$ 编码 $e$ 称为群码，如果所有代码字的集合 $N = e(B^m)$ 是 $B^n$ 的一个**子群**。
- **如何判断:**
	1. $B^n$ 的单位元 $\overline{0}$ 必须在 $N$ 中。
	2. 如果 $x, y \in N$，那么 $x \oplus y$ 也必须在 $N$ 中。（逆元性质自动满足）
- **定理3 (重要):** 对于一个**群码**，其**最短距离**等于所有**非零代码字的最小权**。
- **优势 (例8):** 计算最短距离时，不再需要计算 $\binom{2^m}{2}$ 对代码字之间的距离。只需要查看 $2^m - 1$ 个非零代码字的权，找出最小的那个即可。

### 5. 奇偶校验矩阵 (Parity Check Matrix)

这是构造群码的一种系统方法。

- **布尔矩阵运算:**
	- **加法** $\oplus$**:** 模2加法。
	- **乘法 $\* $:** 矩阵 $D * E$ 的 $f_{ij}$ 项 = $\sum (d_{ik} \cdot e_{kj})$。这里的 $a \cdot b$ 是 $a \wedge b$ (与)，+ 是模2加法。
- **同态** $f_H$**:** 给定一个 $n \times r$ 矩阵 $H$（其中 $r=n-m$），函数 $f_H(x) = x * H$ 是一个从 $B^n$ 到 $B^r$ 的群同态。
- **核 (Kernel):** $f_H$ 的核 $N = \{x \in B^n | x * H = \overline{0}\}$ 是 $B^n$ 的一个正规子群。
- **奇偶校验矩阵 H:**
	- 是一个 $n \times r$ 矩阵。
	- 它的最后 $r$ 行（即 $m+1$ 到 $n$ 行）形成一个 $r \times r$ 单位矩阵 $I_r$。
- **编码函数** $e_H$**:**
	- $e_H: B^m \rightarrow B^n$。
	- 输入 $b = b_1 \dots b_m$。
	- 输出 $x = e_H(b) = b_1 \dots b_m x_1 \dots x_r$。
	- $x_1 \dots x_r$ (校验位) 的计算是为了使 $x * H = \overline{0}$。
	- 计算公式为： $x_j = \sum_{i=1}^{m} (b_i \cdot h_{ij})$。
- **定理6 & 推论2:** $e_H$ 产生的代码字集合 $e_H(B^m)$ 正是 $f_H$ 的核。因此，$e_H$ **是一个群码**。

## 🔬 11.2 译码与纠错

本节介绍如何从收到的（可能出错的）字 $x_t$ 恢复出原始信息 $b$，以及如何纠正错误。

### 1. 译码函数 (Decoding Function)

- **定义:** 给定编码 $e: B^m \rightarrow B^n$，一个 **(n, m) 译码函数** $d: B^n \rightarrow B^m$ 必须满足：
	1. $d$ 是**满射 (Surjective)**。
	2. $d \circ e = I_{B^m}$ (恒等函数)。
- **作用:** 如果传输**没有噪声** ($x_t = e(b)$)，译码函数必须能正确译出 $d(x_t) = b$。
- **例1 (奇偶校验):** $e: B^m \rightarrow B^{m+1}$。译码函数 $d(y_1 \dots y_m y_{m+1}) = y_1 \dots y_m$（即丢弃校验位）。

### 2. 纠错 (Error Correction)

- **定义:** 如果 $x=e(b)$ 在传输中发生 $k$ 个或更少的错误，收到的 $x_t$ 依然能被 $d$ 正确译码为 $b$ (即 $d(x_t) = b$)，则称 $(e, d)$ **能校正k个或更少的错误**。
- **例2 (m, 3m) 编码:**
	- 编码 $e$：将 $b$ 重复三次 (如 $e(011) = 011011011$)。
	- 译码 $d$：对 $y$ 的 $i, i+m, i+2m$ 位进行“多数表决”。如果三个位置中至少有两个1，则译码 $z_i=1$，否则 $z_i=0$。
	- **纠错能力:** 这个 $(e, d)$ 能纠正任意**单一**错误。

### 3. 核心方法：最大似然译码 (Maximum Likelihood Decoding)

这是一种从 $e$ 确定 $d$ 的通用方法。

#### 核心考点：纠错能力与最短距离

- **定理1:** 一个 $(e, d)$ 最大似然译码对能纠正 $k$ 个或更少的错误 **当且仅当** 编码 $e$ 的**最短距离至少是** $2k+1$。
- **证明概要 (为什么是 2k+1):**
	- 假设最短距离 $\ge 2k+1$。
	- $x=e(b)$ 被发送， $x_t$ 被接收，且 $\delta(x, x_t) \le k$ (发生 $\le k$ 个错误)。
	- 对于任何**其他**代码字 $z$，我们有 $\delta(x, z) \ge 2k+1$。
	- 根据三角不等式 $\delta(x, z) \le \delta(x, x_t) + \delta(x_t, z)$。
	- $2k+1 \le k + \delta(x_t, z)$。
	- 解得 $\delta(x_t, z) \ge k+1$。
	- 这意味着 $x_t$ 与 $x$ 的距离($\le k$) **严格小于** $x_t$ 与任何其他代码字 $z$ 的距离($\ge k+1$)。
	- 因此，$x$ 是**惟一**最接近 $x_t$ 的代码字，最大似然译码一定会选择 $x$，从而正确译码出 $b$。
- **解题方法 (如何求** $e$ **能纠正多少个错误):**
	1. 找出 $e$ 的最短距离 $d_{min}$。
	2. 解不等式 $d_{min} \ge 2k+1$。
	3. 得到 $k \le \lfloor \frac{d_{min} - 1}{2} \rfloor$。
	4. $e$ 能纠正的最多错误数 $k$ 就是 $\lfloor \frac{d_{min} - 1}{2} \rfloor$。
- **示例 (例3):** 某编码 $e$ 的最短距离是 3。 $3 \ge 2k+1$，解得 $2 \ge 2k$，即 $k \le 1$。因此，该代码能纠正1个错误。

#### 最大似然译码步骤 (一般情况)

1. 将所有 $2^m$ 个代码字 $N = \{x^{(1)}, \dots, x^{(2^m)}\}$ 按**固定次序**列出。
2. 收到 $x_t$ 后，计算 $x_t$ 与**每一个**代码字 $x^{(i)}$ 的距离 $\delta(x^{(i)}, x_t)$。
3. 选取 $x_t$ 距离最小的**第一个**代码字 $x^{(s)}$。
4. 如果 $x^{(s)} = e(b)$，则译码 $d(x_t) = b$。
5. **注意:** 译码结果 $d$ 依赖于代码字列表的顺序。

### 4. 方法优化：群码的译码 (Coset Decoding)

当 $e$ 是群码时，最大似然译码有更高效的方法。

- **基本原理:**
	- $N = e(B^m)$ 是 $B^n$ 的一个子群。
	- 收到 $x_t$。我们要找的 $x \in N$ 是与 $x_t$ 距离最近的。
	- $\delta(x_t, x) = |x_t \oplus x|$。
	- $x_t \oplus x$ 属于 $x_t$ 所在的**左陪集 (Left Coset)** $x_t \oplus N = \{\epsilon_1, \dots, \epsilon_{2^m}\}$。
	- **关键:** 在 $x_t$ 的陪集 $x_t \oplus N$ 中寻找一个**权最小**的元素 $\epsilon_j$。
	- $\epsilon_j$ 称为 **陪集首部 (Coset Leader)**。（陪集首部可能不惟一）
	- 一旦找到 $\epsilon_j$，则 $x_t$ 对应的代码字 $x$ 就是 $x = x_t \oplus \epsilon_j$。

#### 译码表法 (步骤)

1. **步骤1 & 2 (建表):**
	- 第一行：列出所有代码字 $N$，以 $\overline{0}$ (单位元) 作为该行的陪集首部。
	- 第二行：在 $B^n$ 中选一个未出现在表中的字 $y$。列出其陪集 $y \oplus N$。
	- 在该行中选一个**权最小**的元素作为陪集首部 $\epsilon^{(2)}$。
	- 重写该行，使其变为 $\epsilon^{(2)} \oplus x^{(j)}$ 的形式（即 $\epsilon^{(2)}$ 在最左边）。
	- 重复此过程，直到 $B^n$ (共 $2^n$ 个元素) 中所有元素都被列出。
	- 该表共有 $2^r$ 行（$r = n-m$）。
2. **步骤3 & 4 (译码):**
	- 收到 $x_t$。
	- 在译码表 (如表11.4) 中找到 $x_t$ 的位置。
	- $x_t$ 所在**列的顶端**（即第一行）的元素 $x$，就是距离 $x_t$ 最近的代码字。
	- 如果 $x = e(b)$，则 $d(x_t) = b$。

- **示例 (例4):**
	- 收到 $x_t = 000101$。
	- 在表11.4中找到它在第5列。
	- 第5列顶端的代码字是 $x = 100101$。
	- 因为 $e(100) = 100101$，所以译码为 $b=100$。

### 5. 最佳方法：校验子译码 (Syndrome Decoding)

这是用于 $e_H$ 群码的**最简化**译码方法。

- **校验子 (Syndrome):** 元素 $x \in B^n$ 的校验子是 $x * H$。

- **定理4 (核心):** 两个元素 $x$ 和 $y$ 属于 $B^n$ 中 $N$ 的**同一个左陪集** $\iff$ 它们具有**相同的校验子** ($x * H = y * H$)。

- **推论:**

	> $f_H(x_t) = f_H(\epsilon)$ **一个字** $x_t$ **的校验子 = 它所在陪集的陪集首部** $\epsilon$ **的校验子。** (因为 $f_H(x_t) = f_H(\epsilon \oplus x) = f_H(\epsilon) \oplus f_H(x)$，而 $x$ 是代码字, $f_H(x) = \overline{0}$。)

#### 校验子译码步骤 (解题方法)

1. **步骤1 & 2 (预计算):**
	- 确定 $N=e_H(B^m)$ 的所有 $2^r$ 个左陪集。
	- 为每个陪集找到一个陪集首部 $\epsilon$ (权最小的元素)。
	- 计算**每个陪集首部** $\epsilon$ 的校验子 $f_H(\epsilon) = \epsilon * H$。
	- 制作一个 $2^r$ 行的**查询表**：[校验子 $\rightarrow$ 陪集首部] (如表11.6)。
2. **步骤3 (译码):**
	- 收到 $x_t$。
	- 计算 $x_t$ 的校验子 $S = f_H(x_t) = x_t * H$。
	- 在查询表中查找 $S$，找到对应的陪集首部 $\epsilon$。
	- 计算译码后的代码字 $x = x_t \oplus \epsilon$。
	- 找到 $b$ 使得 $e_H(b) = x$，则 $d(x_t) = b$。

- **优势:** 无需构造 $2^n$ 个元素的完整译码表，只需存储 $2^r$ 个陪集首部及其校验子。
- **示例 (例5):**
	- 收到 $x_t = 001110$。
	- 计算 $x_t$ 的校验子：$f_H(x_t) = 001110 * H = 101$。
	- 查表11.6，校验子 101 对应的陪集首部是 $\epsilon = 010000$。
	- 计算代码字：$x = x_t \oplus \epsilon = 001110 \oplus 010000 = 011110$。
	- 已知 $e(011) = 011110$。
	- 所以 $001110$ 译码为 $011$。